ARMv8-A学习笔记包含以下几个部分：
0.ARMv8-A简要介绍；
1.ARMv8-A寄存器；
2.ARMv8-A指令集介绍；
3.ARMv8-A异常模型及异常处理；
4.ARMv8-A中断处理；
5.ARMv8-A内存管理；
6.ARMv8-A缓存策略；

0.ARMv8-A简要介绍
A53处理器内部结构示意图
如图所示，其内部包括xxx等部分；

0.1 ARMv8-A支持两种执行状态：AArch64和AArch32。
Note：执行状态指的处理器运行时的环境，包括寄存器的位宽、支持的指令集、异常模型、内存管理及编程模型等。
AArch64：64位执行状态
(1)提供31个64位的通用寄存器；
(2)提供64位的PC寄存器、栈指针、异常链接寄存器；
(3)使用A64指令集；
(4)使用ARMv8异常模型，支持4个异常等级，即EL0-EL3。
(5)提供64位的内存模型；
AArch32：32位执行状态：
(1)提供13个32位的通用寄存器，另外加上PC指针，栈指针，链接寄存器；
(2)支持两套指令集，包括A32和T32(Thumb指令集)；
(3)支持ARMv7-A异常模型，基于PE模式并映射到ARMv8的异常模型中；
(4)提供32位的内存模型；

0.2 异常等级
异常等级为软件的逻辑分层提供相应的硬件支持；
(1)EL0:用户特权，用于运行普通用户程序；
(2)EL1:系统特权，用于运行操作系统内核；
(3)EL2:运行虚拟化扩展的虚拟机监控器(hypervisor);
(4)EL3:运行安全世界中的安全监视器(secure monitor);

基于安全性考虑，还分为非安全模式和安全模式，安全模式和非安全模式需要在EL3进行切换，且处理器刚启动时处于安全模式（存疑）；

1.ARMv8-A寄存器
1.1 31个通用寄存器x0/w0-X30/w30，结合ABI讲一讲各个通用寄存器的具体作用，如图1-2；
1.2 特殊寄存器，如zero寄存器，PC寄存器，SPSR处理器状态保存寄存器，异常链接寄存器ELR等，如图所示，需要注意ELR和SPSR没有level0对应的寄存器，意味着无法在level0处理异常；
1.3 PSTATE处理器状态寄存器，如图所示，可保存或设置处理器运行过程中的算术状态，异常状态、调试等功能；
system register，AArch64通过系统寄存器进行新系统设置，系统寄存器只能通过MSR和MRS指令进行访问，例如ACTLR_ELn，ELR_ELn,ESR_ELn,FAR_ELn，MIDR_ELn,MPIDR_ELn等系统寄存器；

2.ARMv8-A异常处理
attention：
EL0不能处理异常；

2.1 ARMv8中异常可分为同步异常和异步异常；
同步异常：处理器执行某条指令，该条指令直接导致处理器出现异常的情况，需要处理完该异常才能继续执行，例如访问不可访问的寄存器、执行系统调用、地址翻译或权限等级导致的数据或指令异常；
异步异常：异常出发原因与处理器当前正在执行的指令无关的异常，如中断；
在PSTATE寄存器中可设置是否屏蔽各种异常，可屏蔽的异常包括DAIF(Debug exceptions mask， SError interrupt Process state mask， IRQ interrupt Process state mask， FIQ interrupt。。。)
2.2 异常处理流程
如图为发生异常时的处理流程：
CPU会进行如下操作：1.保存PC值到ELR_ELn，保存PSTATE到SPSR_ELn，2.对于SError和同步异常，将异常原因写入ESR_ELn寄存器中；3.切换SP寄存器为目标异常等级的SP_ELt或SP_ELh;4.切换异常等级到对应的异常处理等级，并跳转到异常向量表，处理异常；
异常处理完成后通过ERET指令返回；
SCR_EL3和HCR_EL2可设置异常发生后路由到哪个异常等级处理和使用哪种执行状态；
2.3 异常向量表
异常向量表存储异常处理的跳转地址，每个异常级别EL1-3都有自己的异常向量表
如图所示每个异常向量表有4个大处理类别，分别是1.使用SP0处理当前异常等级的异常；2使用SP_ELh处理当前等级的有异常；3.运行于低异常等级且为AArch64执行状态的异常；4.运行于低异常等级且为AArch32的异常；
且每个大的处理类别为4个小异常类别：同步异常，IRQ，FIQ，SError等。

3.ARMv8-A 中断处理

4.ARMv8-A 内存管理
注意EL2和EL3没有TTBR1，EL1有TTBR0和TTBR1
4.1 MMU(Memory Management Unit)内存管理单元主要有两个作用，一个是进行虚拟地址到物理地址的转换，另一个是实现内存地址权限管理，其结构如图所示。
虚拟地址的主要作用是进行内存的逻辑隔离（多任务，多进程之间的虚拟地址互不影响），为编程人员及编译器提供统一的内存视图（程序代码、编译链接均使用虚拟地址），但为了运行时访问到实际的物理地址，就需要进行逻辑地址到物理地址的转换。如图所示：
虚拟地址转换就需要用到TBL(Translation Lookaside Buffer)地址转换查找缓存，缓存页表查询结果。当未从TLB总查询到物理地址时才会访问页表。

4.2 页表
页表存放虚拟地址与物理地址的映射关系，一般存放在内存当中，通常页表可以分为多级，这样可以减少页表存储空间的使用。因为程序刚运行时只需要在内存中放入一级页表，一级页表的地址存放在寄存器TTBRx中，后续可逐步创建二级、三级页表。
如何通过查找页表项实现虚拟地址到物理地址的转换，如图所示：
有两级页表，首先通过虚拟地址的最高位确定从TTBR0或TTBR1中去查找一级页表，根据虚拟地址中29-41位的值作为索引，查找到一级页表中的内容，其中存放有二级页表的地址，然后从16-28位中索引二级页表对应的实际物理地址的高位地址，并加上虚拟地址中的偏移，得到实际的物理地址。
AArch64支持3种地址转换粒度，分别为4K、16K、64K，页表的格式如图所示，页表中不仅包含下一级页表的入口地址，同时也包含页表的一些属性信息：

4.3 权限管理

5. cache
5.1 cache的作用：使用cache的原因主要有两个，1）PE访问主存的时间开销太大；2）程序运行中的局部性原理，通常会频繁访问被读写地址附近的数据。因此采用一块处理器可以快速进行读写访问的空间，将最近被读写的数据进行缓存，提高数据读写速度。
ARMv8-A架构处理器的缓存结构如图所示，通常分为多级缓存，其中每个PE会各存在一个DCache和ICache缓存，每个cluster存在一个缓存，多个cluster存在一个缓存，大概这样一个结构。
5.2 cache基本结构
如图为一个组相连的cache，一个cache通常由多个路way组成，每个way中有多个cache line，cache line是cache缓存主存数据的最小粒度，通常为32或64B，多个索引相同的cache line组成一个组set，高速缓存地址编码由tag、index和offset三部分组成；
通过地址索引到某个特定的cache line的方式如下：1.通过index索引到cache line属于哪一个set；2索引到set后遍历该set中的cache line并比对tag，若tag一致则缓存命中，否则缓存未命中。
如图以32Kcache为例，简单介绍；
高速缓存的策略：
1.读写未命中
如果读或者写一个地址数据未命中，此时会在一级缓存分配一个cache line先缓存待读写的数据，并进行读或者写更新，通常称为Write allocation(WA)或者Read Allocation(RA)
2.读写命中
主要是写的策略。有两种：直写模式和回写模式。
直写模式：数据同时写入当前高速缓存、下一级高速缓存或主存储器中；
回写模式：数据只写入当前高速缓存，不再向下传递。只有当该数据缓存被替换出时，才会更新到下一级缓存或者主存中。
5.3 PoC和PoU
ARM引入POC和POU的概念，以便于后面理解缓存一致性。一致性实际上是由范围的，这个范围就是观测者可以看到的角度，一个机制的设定是有可视范围的，同样也是有盲区的。cpu作为一宫之主并不是所有的信息都及时的掌握。
一致性角度（Point of Coherency），一致性的角度可以说是整SoC的全局角度。要求所有能访问内存的部件，包括PE、DMA、GPU等，所看到的内存都是一致的，没有任何歧义。
统一性角度（Point of Unification），统一性是站在core层级而言的，core能看见的是i-cache，d-cache、TLB、MMU这些。
理解POC和POU可以帮助我们确定程序何时需要关注或者保证缓存一致性，何时下刷cache，何时不需要下刷cache。
5.4 缓存一致性
